#!/usr/bin/env bash
#=
exec julia --color=yes --project="${BASH_SOURCE[0]%/*}" "${BASH_SOURCE[0]}" "$@"
=#

print("Loading QuTiE...\r")
flush(stdout)
using ProgressMeter
requirements = quote
    using QuTiE
    using DifferentialEquations
    using AlgebraOfGraphics
    using LaTeXStrings
    # using Makie
    # try
    #     using GLMakie
    # catch
    #     using CairoMakie
    # end
    using Revise
    using PhysicalConstants: CODATA2018, PhysicalConstant
end
@showprogress 0.5 "Loading QuTiE..." for requirement âˆˆ requirements.args
    @eval $requirement
end

for name âˆˆ names(CODATA2018, all=true)
    @eval if CODATA2018.$name isa PhysicalConstant
        import PhysicalConstants.CODATA2018: $name
    end
end

const Ä§Â² = Ä§^2
const ğ‘– = im
âˆœ(x::â„) = x^(1/4)

__revise_mode__ = :evalassign

function main(arguments::String...)
    length(arguments) == 1 && ARGS[1] âˆ‰ ("-h", "--help", "-?") || error("Usage: ./$(normpath(PROGRAM_FILE)) spec.jl")
    includet(arguments[1])
    isdefined(:Ïˆâ‚€) || error("Must define initial state Ïˆâ‚€")
    if isdefined(:H) || isdefined(:â„‹)
        if isdefined(:H) && isdefined(:â„‹)
            error("Cannot define both H and â„‹")
        end
        if isdefined(:L) || isdefined(:â„’)
            error("Cannot define both Hamiltonian and Lagrangian")
        end
        if isdefined(:â„‹)
            # Canonicalize:
            H = â„‹
        end
        # Hamiltonian formulation:
        Ïˆ = Observable([(
            filter_type(Space, op)
            |> unique
            |> Volume
            |> ones
            |> Base.Fix1(*, Ïˆâ‚€)
        )])
        integrator = init(ODEProblem(-im*H/Ä§, Ïˆ[][begin], (0, âˆ)))
    end
    if isdefined(:L) || isdefined(:â„’)
        if isdefined(:L) && isdefined(:â„’)
            error("Cannot define both L and â„’")
        end
        if isdefined(:H) || isdefined(:â„‹)
            error("Cannot define both Lagrangian and Hamiltonian")
        end
        if isdefined(:â„’)
            # Canonicalize:
            L = â„’
        end
        # v2: Lagrangian formulation
    end
    if !isdefined(:ğŸ“Š) && isdefined(:output)
        ğŸ“Š = output
    end
    if !isdefined(:ğŸ“Š)
        ğŸ“Š = visual(Wireframe)
    end
    if isdefined(:x)
        # Cartesian default.
        if isdefined(:y)
            if isdefined(:z)
            end
        end
    elseif isdefined(:r) || isdefined(:Ï)
        if isdefined(:Î¸) && isdefined(:Ï†)
            # Spherical default.
        elseif (isdefined(:Î¸) || isdefined(:Ï†)) && isdefined(:z)
            #
        end
    else
    end
    Ïˆ = Observable(Ïˆâ‚€*ones(axes(H)))
    draw(data(Ïˆ)*ğŸ“Š)
    for (Ïˆ, t) âˆˆ tuples(integrator)
        @show Ïˆ, t
    end
end

function julia_main()::Cint
    try
        main(ARGS...)
    catch
        Base.invokelatest(Base.display_error, Base.catch_stack())
        return 1
    end
    return 0
end

if abspath(PROGRAM_FILE) == @__FILE__
    main(ARGS...)
end

# Local Variables:
# mode: julia
# End:
