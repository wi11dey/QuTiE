#!/usr/bin/env bash
#=
exec julia --color=yes --threads=auto --project="${BASH_SOURCE[0]%/*}" "${BASH_SOURCE[0]}" "$@"
=#

print("Loading QuTiE...\r")
flush(stdout)
using ProgressMeter
requirements = quote
    using QuTiE
    using PhysicalConstants: CODATA2018, PhysicalConstant
    using DifferentialEquations
    using LaTeXStrings
    using Revise
    # using AlgebraOfGraphics
    # using Makie
    # try
    #     using GLMakie
    # catch
    #     using CairoMakie
    # end
end
@showprogress 0.5 "Loading QuTiE..." for requirement âˆˆ requirements.args
    @eval $requirement
end

for name âˆˆ names(CODATA2018, all=true)
    getproperty(CODATA2018, name) isa PhysicalConstant || continue
    @eval import PhysicalConstants.CODATA2018: $name
    synonym = Symbol(replace(string(name), r"_.+$"=>QuTiE.subâˆ˜Base.Fix2(SubString, 2)))
    synonym == name && continue
    @eval const $synonym = $name
end

const Ä§Â² = Ä§^2
const ğ‘– = im
âˆœ(x::â„) = x^(1/4)
const t = Time()

__revise_mode__ = :evalassign

function main(arguments::String...)
    length(arguments) == 1 && ARGS[1] âˆ‰ ("-h", "--help", "-?") || error("Usage: ./$(normpath(PROGRAM_FILE)) spec.jl")
    includet(arguments[1])
    isdefined(Main, :Ïˆâ‚€) || error("Must define initial state Ïˆâ‚€")
    if isdefined(Main, :H) || isdefined(Main, :â„‹)
        if isdefined(Main, :H) && isdefined(Main, :â„‹)
            error("Cannot define both H and â„‹")
        end
        if isdefined(Main, :L) || isdefined(Main, :â„’)
            error("Cannot define both Hamiltonian and Lagrangian")
        end
        if isdefined(Main, :â„‹)
            # Canonicalize:
            H = â„‹
        end
        # Hamiltonian formulation:
        # Ïˆ = Observable([(
        #     filter_type(Space, op)
        #     |> unique
        #     |> Volume
        #     |> ones
        #     |> Base.Fix1(*, Ïˆâ‚€)
        # )])
        # integrator = init(ODEProblem(-im*H/Ä§, Ïˆ[][begin], (0, âˆ)))
    end
    if isdefined(Main, :L) || isdefined(Main, :â„’)
        if isdefined(Main, :L) && isdefined(Main, :â„’)
            error("Cannot define both L and â„’")
        end
        if isdefined(Main, :H) || isdefined(Main, :â„‹)
            error("Cannot define both Lagrangian and Hamiltonian")
        end
        if isdefined(Main, :â„’)
            # Canonicalize:
            L = â„’
        end
        # v2: Lagrangian formulation
    end
    # if !isdefined(Main, :ğŸ“Š) && isdefined(Main, :output)
    #     ğŸ“Š = output
    # end
    # if !isdefined(Main, :ğŸ“Š)
    #     ğŸ“Š = visual(Wireframe)
    # end
    # if isdefined(Main, :x)
    #     # Cartesian default.
    #     if isdefined(Main, :y)
    #         if isdefined(Main, :z)
    #         end
    #     end
    # elseif isdefined(Main, :r) || isdefined(Main, :Ï)
    #     if isdefined(Main, :Î¸) && isdefined(Main, :Ï†)
    #         # Spherical default.
    #     elseif (isdefined(Main, :Î¸) || isdefined(Main, :Ï†)) && isdefined(Main, :z)
    #         #
    #     end
    # else
    # end
    # Ïˆ = Observable(Ïˆâ‚€*))
    # draw(data(Ïˆ)*ğŸ“Š)
    # for (Ïˆ, t) âˆˆ tuples(integrator)
    #     @show Ïˆ, t
    # end
    ones(axes(H))
end

function julia_main()::Cint
    try
        main(ARGS...)
    catch
        Base.invokelatest(Base.display_error, Base.catch_stack())
        return 1
    end
    return 0
end

if abspath(PROGRAM_FILE) == @__FILE__
    main(ARGS...)
end

# Local Variables:
# mode: julia
# End:
